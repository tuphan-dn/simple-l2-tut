/**
 * @packageDocumentation
 *
 * **Supported Key Types**
 *
 * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.
 *
 * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.
 *
 * For encryption / decryption support, RSA keys should be used.
 */
import type { PrivateKey, PublicKey, KeyType, RSAPrivateKey, Secp256k1PrivateKey, Ed25519PrivateKey, Secp256k1PublicKey, Ed25519PublicKey } from '@libp2p/interface';
import type { MultihashDigest } from 'multiformats';
export { generateEphemeralKeyPair } from './ecdh/index.js';
export { keyStretcher } from './key-stretcher.js';
/**
 * Generates a keypair of the given type and bitsize
 */
export declare function generateKeyPair(type: 'Ed25519'): Promise<Ed25519PrivateKey>;
export declare function generateKeyPair(type: 'secp256k1'): Promise<Secp256k1PrivateKey>;
export declare function generateKeyPair(type: 'RSA', bits?: number): Promise<RSAPrivateKey>;
export declare function generateKeyPair(type: KeyType, bits?: number): Promise<PrivateKey>;
/**
 * Generates a keypair of the given type from the passed seed.  Currently only
 * supports Ed25519 keys.
 *
 * Seed is a 32 byte uint8array
 */
export declare function generateKeyPairFromSeed(type: 'Ed25519', seed: Uint8Array): Promise<Ed25519PrivateKey>;
export declare function generateKeyPairFromSeed<T extends KeyType>(type: T, seed: Uint8Array, bits?: number): Promise<never>;
/**
 * Converts a protobuf serialized public key into its representative object
 */
export declare function publicKeyFromProtobuf(buf: Uint8Array): PublicKey;
/**
 * Creates a public key from the raw key bytes
 */
export declare function publicKeyFromRaw(buf: Uint8Array): PublicKey;
/**
 * Creates a public key from an identity multihash which contains a protobuf
 * encoded Ed25519 or secp256k1 public key.
 *
 * RSA keys are not supported as in practice we they are not stored in identity
 * multihashes since the hash would be very large.
 */
export declare function publicKeyFromMultihash(digest: MultihashDigest<0x0>): Ed25519PublicKey | Secp256k1PublicKey;
/**
 * Converts a public key object into a protobuf serialized public key
 */
export declare function publicKeyToProtobuf(key: PublicKey): Uint8Array;
/**
 * Converts a protobuf serialized private key into its representative object
 */
export declare function privateKeyFromProtobuf(buf: Uint8Array): Ed25519PrivateKey | Secp256k1PrivateKey | RSAPrivateKey;
/**
 * Creates a private key from the raw key bytes. For Ed25519 keys this requires
 * the public key to be appended to the private key otherwise we can't
 * differentiate between Ed25519 and secp256k1 keys as they are the same length.
 */
export declare function privateKeyFromRaw(buf: Uint8Array): PrivateKey;
/**
 * Converts a private key object into a protobuf serialized private key
 */
export declare function privateKeyToProtobuf(key: PrivateKey): Uint8Array;
//# sourceMappingURL=index.d.ts.map