/**
 * @packageDocumentation
 *
 * **Supported Key Types**
 *
 * The {@link generateKeyPair}, {@link marshalPublicKey}, and {@link marshalPrivateKey} functions accept a string `type` argument.
 *
 * Currently the `'RSA'`, `'ed25519'`, and `secp256k1` types are supported, although ed25519 and secp256k1 keys support only signing and verification of messages.
 *
 * For encryption / decryption support, RSA keys should be used.
 */
import { UnsupportedKeyTypeError } from '@libp2p/interface';
import { generateEd25519KeyPair, generateEd25519KeyPairFromSeed, unmarshalEd25519PrivateKey, unmarshalEd25519PublicKey } from './ed25519/utils.js';
import * as pb from './keys.js';
import { pkcs1ToRSAPrivateKey, pkixToRSAPublicKey, generateRSAKeyPair } from './rsa/utils.js';
import { generateSecp256k1KeyPair, unmarshalSecp256k1PrivateKey, unmarshalSecp256k1PublicKey } from './secp256k1/utils.js';
export { generateEphemeralKeyPair } from './ecdh/index.js';
export { keyStretcher } from './key-stretcher.js';
export async function generateKeyPair(type, bits) {
    if (type === 'Ed25519') {
        return generateEd25519KeyPair();
    }
    if (type === 'secp256k1') {
        return generateSecp256k1KeyPair();
    }
    if (type === 'RSA') {
        return generateRSAKeyPair(bits ?? 2048);
    }
    throw new UnsupportedKeyTypeError();
}
export async function generateKeyPairFromSeed(type, seed) {
    if (type !== 'Ed25519') {
        throw new UnsupportedKeyTypeError('Seed key derivation only supported for Ed25519 keys');
    }
    return generateEd25519KeyPairFromSeed(seed);
}
/**
 * Converts a protobuf serialized public key into its representative object
 */
export function publicKeyFromProtobuf(buf) {
    const { Type, Data } = pb.PublicKey.decode(buf);
    const data = Data ?? new Uint8Array();
    switch (Type) {
        case pb.KeyType.RSA:
            return pkixToRSAPublicKey(data);
        case pb.KeyType.Ed25519:
            return unmarshalEd25519PublicKey(data);
        case pb.KeyType.secp256k1:
            return unmarshalSecp256k1PublicKey(data);
        default:
            throw new UnsupportedKeyTypeError();
    }
}
/**
 * Creates a public key from the raw key bytes
 */
export function publicKeyFromRaw(buf) {
    if (buf.byteLength === 32) {
        return unmarshalEd25519PublicKey(buf);
    }
    else if (buf.byteLength === 33) {
        return unmarshalSecp256k1PublicKey(buf);
    }
    else {
        return pkixToRSAPublicKey(buf);
    }
}
/**
 * Creates a public key from an identity multihash which contains a protobuf
 * encoded Ed25519 or secp256k1 public key.
 *
 * RSA keys are not supported as in practice we they are not stored in identity
 * multihashes since the hash would be very large.
 */
export function publicKeyFromMultihash(digest) {
    const { Type, Data } = pb.PublicKey.decode(digest.digest);
    const data = Data ?? new Uint8Array();
    switch (Type) {
        case pb.KeyType.Ed25519:
            return unmarshalEd25519PublicKey(data);
        case pb.KeyType.secp256k1:
            return unmarshalSecp256k1PublicKey(data);
        default:
            throw new UnsupportedKeyTypeError();
    }
}
/**
 * Converts a public key object into a protobuf serialized public key
 */
export function publicKeyToProtobuf(key) {
    return pb.PublicKey.encode({
        Type: pb.KeyType[key.type],
        Data: key.raw
    });
}
/**
 * Converts a protobuf serialized private key into its representative object
 */
export function privateKeyFromProtobuf(buf) {
    const decoded = pb.PrivateKey.decode(buf);
    const data = decoded.Data ?? new Uint8Array();
    switch (decoded.Type) {
        case pb.KeyType.RSA:
            return pkcs1ToRSAPrivateKey(data);
        case pb.KeyType.Ed25519:
            return unmarshalEd25519PrivateKey(data);
        case pb.KeyType.secp256k1:
            return unmarshalSecp256k1PrivateKey(data);
        default:
            throw new UnsupportedKeyTypeError();
    }
}
/**
 * Creates a private key from the raw key bytes. For Ed25519 keys this requires
 * the public key to be appended to the private key otherwise we can't
 * differentiate between Ed25519 and secp256k1 keys as they are the same length.
 */
export function privateKeyFromRaw(buf) {
    if (buf.byteLength === 64) {
        return unmarshalEd25519PrivateKey(buf);
    }
    else if (buf.byteLength === 32) {
        return unmarshalSecp256k1PrivateKey(buf);
    }
    else {
        return pkcs1ToRSAPrivateKey(buf);
    }
}
/**
 * Converts a private key object into a protobuf serialized private key
 */
export function privateKeyToProtobuf(key) {
    return pb.PrivateKey.encode({
        Type: pb.KeyType[key.type],
        Data: key.raw
    });
}
//# sourceMappingURL=index.js.map